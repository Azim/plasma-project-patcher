#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using BepInEx;
using BepInEx.Bootstrap;
using BepInEx.Logging;
using GameNetcodeStuff;
using HarmonyLib;
using Mono.Cecil;
using MonoMod.Cil;
using MonoMod.RuntimeDetour;
using UnityEditor;
using UnityEngine;
using Debug = UnityEngine.Debug;

public class BepInExPatcher: MonoBehaviour {
    private static string LethalCompanyDataFolder {
        get {
            var path = EditorPrefs.GetString("nomnom.lc_project_patcher.lc_data_folder");
            if (string.IsNullOrEmpty(path)) {
                return null;
            }
                
            if (!path.EndsWith("_Data")) {
                var folderName = Path.GetFileNameWithoutExtension(path);
                var dataFolder = $"{folderName}_Data";
                path = Path.Combine(path, dataFolder);

                if (!Directory.Exists(path)) {
                    Debug.LogError("The data path needs to end in \"_Data\"!");
                    return null;
                }
            }

            return path;
        }
    }
    
    private static string ActualExePath => Path.Combine(LethalCompanyDataFolder, "..", "Lethal Company.exe");
    private static string FakeExePath => Path.Combine(Application.dataPath, "..", "Lethal Company", "Lethal Company.exenot");
    private static string DirectoryPath => Path.GetDirectoryName(ActualExePath);
    private static string GameDataPath => Path.Combine(DirectoryPath, "Lethal Company_Data");
    private static string ManagedPath => Path.Combine(GameDataPath, "Managed");

    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]
    private static void OnLoad() {
        var stopwatch = new System.Diagnostics.Stopwatch();
        stopwatch.Start();
        ResetNetcodeRpcTables.ResetRpcFuncTable();

        var useGameBepInEx = EditorPrefs.GetBool("nomnom.lc_project_patcher.use_game_bepinex", false);
        var filePath = useGameBepInEx ? ActualExePath : FakeExePath;
        var setExecutablePath = typeof(Paths).GetMethod("SetExecutablePath", BindingFlags.NonPublic | BindingFlags.Static);
        setExecutablePath.Invoke(null, new object[] { filePath, null, null, null });

        // reset logger sources
        var sources = typeof(BepInEx.Logging.Logger).GetProperty("Sources", BindingFlags.Public | BindingFlags.Static);
        var sourcesValue = (ICollection<ILogSource>)sources.GetValue(null);
        sourcesValue.Clear();
        
        // reset _Listeners
        var listeners = typeof(BepInEx.Logging.Logger).GetField("_Listeners", BindingFlags.NonPublic | BindingFlags.Static);
        var listenersValue = (ICollection<ILogListener>)listeners.GetValue(null);
        listenersValue.Clear();
        
        // reset Chainloader._initialized
        var initialized = typeof(Chainloader).GetField("_initialized", BindingFlags.NonPublic | BindingFlags.Static);
        initialized.SetValue(null, false);
        
        // reset _loaded
        var loaded = typeof(Chainloader).GetField("_loaded", BindingFlags.NonPublic | BindingFlags.Static);
        loaded.SetValue(null, false);
        
        // reset internalLogsInitialized
        var internalLogsInitialized = typeof(BepInEx.Logging.Logger).GetField("internalLogsInitialized", BindingFlags.NonPublic | BindingFlags.Static);
        internalLogsInitialized.SetValue(null, false);
        
        // change UnityLogListener.WriteStringToUnityLog to debug log
        var writeStringToUnityLog = typeof(BepInEx.Logging.UnityLogListener).GetField("WriteStringToUnityLog", BindingFlags.NonPublic | BindingFlags.Static);
        writeStringToUnityLog.SetValue(null, new Action<string>(Debug.Log));
        
        var harmony = new Harmony("com.nomnom.test-bepinex");
        harmony.PatchAll(typeof(FindPluginTypesPatch));
        harmony.PatchAll(typeof(OverrideEditorCheck));
        
        // let up do something dumb! :)
        // get all dlls from game's plugins and manually load them since
        // sub-dependencies are not always loaded
        var gamePlugins = Path.Combine(Path.GetDirectoryName(filePath), "BepInEx", "plugins");
        var gameDlls = Directory.GetFiles(gamePlugins, "*.dll", SearchOption.AllDirectories);
        foreach (var gameDll in gameDlls) {
            Debug.Log($"Loading {Path.GetFileName(gameDll)}");
            try {
                Assembly.LoadFile(gameDll);
            } catch (Exception e) {
                Debug.LogError($"Failed to load {gameDll}: {e}");
            }
        }
        
        Chainloader.Initialize(filePath, false);
        
        if (!useGameBepInEx) {
            OverridePaths();
        } else {
            Debug.Log("Using the normal game's BepInEx folder");
        }
        // DebugPaths();
        
        harmony.PatchAll(typeof(IgnoreILHelpers));
        Chainloader.Start();
        harmony.UnpatchSelf();
        
        Debug.Log("Loaded BepInEx!");
        
        var obj = new GameObject("CustomPlugin");
        obj.AddComponent<BepInExPatcher>();
        DontDestroyOnLoad(obj);
        
        Debug.Log($"BepInExPatcher took {stopwatch.ElapsedMilliseconds}ms to load");
    }

    private static void OverridePaths() {
        Debug.Log($"Using local BepInEx");
        
        // ExecutablePath
        var executablePathProperty = typeof(Paths).GetProperty("ExecutablePath");
        executablePathProperty.SetValue(null, ActualExePath);
        
        // ManagedPath
        var managedPathProperty = typeof(Paths).GetProperty("ManagedPath");
        managedPathProperty.SetValue(null, ManagedPath);
        
        // DllSearchPaths
        var dllSearchPathsProperty = typeof(Paths).GetProperty("DllSearchPaths");
        dllSearchPathsProperty.SetValue(null, new string[] {ManagedPath});
    }

    private static void DebugPaths() {
        Debug.Log($"BepInExAssemblyDirectory: {Paths.BepInExAssemblyDirectory}");
        Debug.Log($"BepInExAssemblyPath: {Paths.BepInExAssemblyPath}");
        Debug.Log($"BepInExRootPath: {Paths.BepInExRootPath}");
        Debug.Log($"ExecutablePath: {Paths.ExecutablePath}");
        Debug.Log($"GameRootPath: {Paths.GameRootPath}");
        Debug.Log($"ManagedPath: {Paths.ManagedPath}");
        Debug.Log($"ConfigPath: {Paths.ConfigPath}");
        Debug.Log($"BepInExConfigPath: {Paths.BepInExConfigPath}");
        Debug.Log($"CachePath: {Paths.CachePath}");
        Debug.Log($"PatcherPluginPath: {Paths.PatcherPluginPath}");
        Debug.Log($"PluginPath: {Paths.PluginPath}");
        Debug.Log($"ProcessName: {Paths.ProcessName}");
    }

    private void OnDestroy() {
        Harmony.UnpatchAll();
        ResetNetcodeRpcTables.DidReset = false;
    }

    [HarmonyPatch(typeof(Chainloader))]
    private static class OverrideEditorCheck {
        [HarmonyPatch("IsEditor", MethodType.Getter)]
        [HarmonyPostfix]
        private static void Get(ref bool __result) {
            __result = false;
        }
    }
    
    [HarmonyPatch]
    private static class FindPluginTypesPatch {
        public static MethodBase TargetMethod() {
            return AccessTools
                .Method(typeof(TypeLoader), nameof(TypeLoader.FindPluginTypes))
                .MakeGenericMethod(typeof(PluginInfo));
        }

        public static Dictionary<string, List<PluginInfo>> Postfix(Dictionary<string, List<PluginInfo>> result) {
            var file = typeof(FindPluginTypesPatch).Module.FullyQualifiedName;
            var assemblyDefinition = AssemblyDefinition.ReadAssembly(file, TypeLoader.ReaderParameters);
            var hasBepinPluginsFunction = AccessTools.Method(typeof(Chainloader), "HasBepinPlugins");

            if (!(bool)hasBepinPluginsFunction.Invoke(null, new object[] { assemblyDefinition })) {
                result[file] = new List<PluginInfo>();
                assemblyDefinition.Dispose();
                Debug.Log("No BepInEx plugins found in Assembly-CSharp!");
            } else {
                var list = assemblyDefinition.MainModule.Types
                    .Select(Chainloader.ToPluginInfo)
                    .Where(t => t != null)
                    .ToList();
                result[file] = list;
                assemblyDefinition.Dispose();
                Debug.Log($"Found {list.Count} BepInEx plugins in Assembly-CSharp!");
            }

            return result;
        }
    }

    [HarmonyPatch]
    private static class IgnoreILHelpers {
        public static IEnumerable<MethodBase> TargetMethods() {
           return AppDomain.CurrentDomain
               .GetAssemblies()
               .SelectMany(x => AccessTools.GetTypesFromAssembly(x)
                   .Where(y => typeof(BaseUnityPlugin).IsAssignableFrom(y))
               )
               .SelectMany(x => x.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
               .Where(x => x.Name == "IlHook")
               .Cast<MethodBase>();
        }

        public static bool Prefix() {
            return false;
        }
    }
}
#endif